<!----- Conversion time: 0.718 seconds.
Using this Markdown file:

1. Cut and paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β17
* Wed Sep 18 2019 01:52:00 GMT-0700 (PDT)
* Source doc: https://docs.google.com/open?id=1SEODmwLcgVdQijJMZ6Xc3YQ0lqnkc72w-gccG4AkpqU
----->

## Создание простого многопоточного сервера

### Цель работы

Познакомиться с приемами работы с многопоточностью на примере создания сокетного TCP-сервера, способного работать с несколькими клиентами одновременно

### Задания для выполнения

1. Создать простой эхо-сервер и клиент для него.
3. Модифицировать код сервера таким образом, чтобы при подключении нового клиента создавался новый поток и вся работа с клиентом выполнялась в нем.

![image](https://user-images.githubusercontent.com/70547060/138162029-87ce2759-c451-4ddd-96ab-6eb8e850cf04.png)

![image](https://user-images.githubusercontent.com/70547060/138162049-8a04381a-f1d5-4979-8835-e16cb221c99a.png)

3. Проверить возможность подключения нескольких клиентов к этому серверу одновременно. 

![image](https://user-images.githubusercontent.com/70547060/138162158-f2abd2dc-6e3b-4a16-b57f-6b39c17dfbc2.png)

### Контрольные вопросы

1. Почему однопоточное приложение не может решить задачу одновременного подключения?

Потому что в однопоточном приложении команды выполняются последовательно, а значит нельзя выполнять 2 или более команды одновременно, соответственно никакого одновременного подключения быть не может.

2. Чем поток отличается от процесса?

Процессы и потоки связаны друг с другом, но при этом имеют существенные различия.

Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

3. Как создать новый поток?

При помощи модуля Threading и его класса Thread

```python
import threading 

def proc(n):
   print "Процесс", n
 
p1 = threading.Thread(target=proc, name="t1", args=["1"])
p2 = threading.Thread(target=proc, name="t2", args=["2"])
p1.start()
p2.start()
```

4. Как выделить участок кода так, чтобы он выполнялся в другом потоке?

Когда мы создаем поток, мы делаем определенную функцию его целью, задаем "target". Соответственно, для того, чтобы участок кода выполнялся в другом потоке, нужно, чтобы это было функция.

5. В чем проблема потокобезопасности?

Потоковая безопасность — это концепция программирования, применимая к многопоточным программам. Код потокобезопасен, если он функционирует исправно при использовании его из нескольких потоков одновременно. В частности, он должен обеспечивать правильный доступ нескольких потоков к разделяемым данным.


### Дополнительные задания

2. Модифицировать простой эхо-сервер таким образом, чтобы при подключении клиента создавался новый поток, в котором происходило взаимодействие с ним.

![image](https://user-images.githubusercontent.com/70547060/138312150-5e63a458-d835-42a4-b5ce-44a6ee89ec49.png)

![image](https://user-images.githubusercontent.com/70547060/138312224-b0060d76-e111-440e-a444-a596969fb442.png)

3. Реализовать простой чат сервер на базе сервера аутентификации. Сервер должен обеспечивать подключение многих пользователей одновременно, отслеживание имен пользователей, поддерживать историю сообщений и пересылку сообщений от каждого пользователя всем остальным. 
4. Реализовать сервер с управляющим потоком. При создании сервера прослушивание портов происходит в отдельном потоке, а главный поток программы в это время способен принимать команды от пользователя. Необходимо реализовать следующие команды:
    
    ![image](https://user-images.githubusercontent.com/70547060/138312407-5563401a-24b7-4564-9f8e-2617f0a5cb4f.png)
    
    1. Отключение сервера (завершение программы);
    
    ![image](https://user-images.githubusercontent.com/70547060/138312456-1cf574f1-4448-4020-92be-174eacb2d1b8.png)

    2. Пауза (остановка прослушивание порта);
    
    ![image](https://user-images.githubusercontent.com/70547060/138312512-9c45b828-d120-4cab-80d1-3e87ce9055f3.png)
    
    3. Показ логов;
    
    ![image](https://user-images.githubusercontent.com/70547060/138312612-06351ad8-34e0-4263-9bca-419b69548360.png)

    4. Очистка логов;
    
    ![image](https://user-images.githubusercontent.com/70547060/138312653-eb8767c4-c4ae-4c0d-b456-ba72c08ebee4.png)
    
    5. Очистка файла идентификации.

#### Дополнительные задания 2 и 4 выполнены и лежат в папке "Многопоточный сервер с управляющим потоком", дополнительное задание 3 выполнено и лежит в папке "Простой чат сервер на базе сервера аутентификации". 
<!-- Docs to Markdown version 1.0β17 -->
